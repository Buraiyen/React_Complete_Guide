#+TITLE: Section 4: React State & Working with Events
#+AUTHOR: Brian E. Nguyen

* Module Introduction
In this module, we will take a closer look at the following
- user interaction
  - this includes events like click, inputs, etc.
- state management
  - so far we can only build static applications where the state never changes, and that's not what we want

* Listening to Events & Working With Event Handlers

- we only have one state in our application, which is the inital state
- let's start with clicks on a button which you want something to happen
- in the ~ExpenseItem~ component, let's add a button tag
  - this will be a temporary button with no styles so that we can practice with React states

#+begin_src javascript
// Expense Item
import ExpenseDate from "./ExpenseDate";
import Card from "../UI/Card";
import "./ExpenseItem.css";

const ExpenseItem = (props) => {
  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button>Change Title</button>
    </Card>
  );
};

export default ExpenseItem;
#+end_src

- the goal of this button is to change the title when the button is clicked
- React has a simple way of detecting button clicks
- on all built-in HTML elements, we have full access to native DOM events which we can listen to
- we will add a special prop in JSX called ~on~. This can be followed by ~onClick~, etc.
  - from there, we can add JavaScript logic to it

#+begin_src javascript
import ExpenseDate from "./ExpenseDate";
import Card from "../UI/Card";
import "./ExpenseItem.css";

const ExpenseItem = (props) => {
  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button onClick={() => {console.log('Clicked!')}}>Change Title</button>
    </Card>
  );
};

export default ExpenseItem;
#+end_src

- we typically want to define a function before the ~return~ statement

#+begin_src javascript
import ExpenseDate from "./ExpenseDate";
import Card from "../UI/Card";
import "./ExpenseItem.css";

const ExpenseItem = (props) => {
  const clickHandler = () => {
    console.log("Clicked!");
  };
  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button onClick={clickHandler}>Change Title</button>
    </Card>
  );
};

export default ExpenseItem;
#+end_src

- when we call the function, we don't add parentheses to it. Why? Because JavaScript will execute the function when the entire JSX line is parsed
- it's a convention that these functions end with ~Handler~. Not everyone does this, but take note of it

* How Component Functions Are Executed

- reacting to events is an important first step. How can we now change what shows up on the screen?
- we can add a new variable called ~title~ and pass it into the JSX code.
- now that we created a variable, we can use the ~clickHandler~ function to let us change the title

#+begin_src javascript
// ExpenseItem.js
import ExpenseDate from "./ExpenseDate";
import Card from "../UI/Card";
import "./ExpenseItem.css";

const ExpenseItem = (props) => {
  let title = props.title;

  const clickHandler = () => {
    title = "Updated!";
  };
  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button onClick={clickHandler}>Change Title</button>
    </Card>
  );
};

export default ExpenseItem;
#+end_src

- but if we were to actually click on the button, the title doesn't change. Why is that? The click handler still executed though and the value of ~title~ is "Updated!"
- the reason is simply because React doesn't work like this. We'll dive deeper into the reason later in the course
- what you need to know right now is that your component is a function; the only special thing about this function is that it returns JSX code
- we never explicity call our component functions. We just use them like HTML elements
- *the main point:* by using components like HTML elements, we make React aware of these component functions. When React evaluates the JSX, it will call the component functions
  + then the component functions will call any component functions inside of them. This process will repeat itself until there is no more JSX
- now, we need a way to tell React to reevaluate these component functions when we execute a handler

* Working with 'State'

- /state/ is not a React-specific concept
- we need to trigger a re-evaluation so that we can change our title
  + note that variables, like ~title~ are not triggered in the re-evaluation
  + React doesn't care about that. The component function doesn't get re-evaluated just because a variable changed
- to tell React that the component function should run again, we need to import something from the React library called ~useState~
  + this is a function provided by the React library which allows us to define values as state, where changes to these values should reflect in the component function

#+begin_src javascript
import React, { useState } from 'react';
#+end_src

- /inside/ of our component function, we just call ~useState~ to use it
- /tip:/ hook functions start with /use/ and can only be called inside component functions, but not inside nested functions
- with ~useState~, it wants a default-state value. We can assign an initial variable of ~props.title~ and pass it as an argument inside ~useState~

#+begin_src javascript
// ExpenseItem.js
import React, { useState } from "react";

import ExpenseDate from "./ExpenseDate";
import Card from "../UI/Card";
import "./ExpenseItem.css";

const ExpenseItem = (props) => {
  useState(props.title);

  let title = props.title;

  const clickHandler = () => {
    title = "Updated!";
  };
  return
...
}
#+end_src

- ~useState~ not only lets us use the special variable in other places, but it also returns a function that we can call to assign a new value to that variable
  + ~useState~ returns an array where it has two values inside of it:
    1. the variable itself
    2. the updating function
  + you can use array-destructuring to retrieve these values

#+begin_src javascript
const [title, setTitle] = useState(props.title)
#+end_src

- this is now what the updated function looks like with ~setTitle~ in use

#+begin_src javascript
const ExpenseItem = (props) => {
  const [title, setTitle] = useState(props.title);

  const clickHandler = () => {
    setTitle("Updated!");
  };
  ...
}
#+end_src

- note that the ~setTitle~ function doesn't only assign the new value to a new variable, but it is also managed by React somewhere in memory because it's a special variable
- now when we click on a button, the title now updates it
